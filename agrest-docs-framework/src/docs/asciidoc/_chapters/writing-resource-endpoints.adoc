== Writing Resource Endpoints

Let's create a resource class called DomainResource, annotated with JAX-RS @Path and
@Produces annotations. One extra thing we need for Agrest to work is an instance of
`javax.ws.rs.core.Configuration`, that can be injected with `@Context` annotation:

[source, Java]
----
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.Context;

@Path("domain")
@Produces(MediaType.APPLICATION_JSON)
public class DomainResource {

    @Context
    private Configuration config;
}
----

=== Create Entity with `POST`

Now let's implement a `POST` method in DomainResource class:

[source, Java]
----
import io.agrest.Ag;
import io.agrest.SimpleResponse;

...

@POST
public SimpleResponse create(String data) {
    return Ag.create(Domain.class, config).sync(data);
}
----

Here we've built a very simple "create chain" using Agrest fluent API. It starts with a
static "create" method on Agrest class, taking a type of entity to create (Domain) and
previously injected Configuration. Finally it calls "sync" method to execute the
request. "data" String is expected to be an "Update Document" (see link:/protocol#request-update-document[Request: Update Document]), i.e. a single object or an array of objects.
Now if you compile your app and deploy it in a web container (e.g. Tomcat), you may call
this endpoint to create new Domain objects:

```
curl -i -X POST 'http://example.org/myapp/domain' \
>          -d '{"vhost":"mysite1.example.org","name":"My Site #1"}'
```

[source, JSON]
----
HTTP/1.1 201 Created
Content-Type: application/json

{"success":true}
----

In your container log you might see output from Cayenne, actually inserting a newly created object:

[source, sh]
----
INFO CommonsJdbcEventLogger - INSERT INTO "domain" ("name", "vhost") VALUES (?, ?)
INFO CommonsJdbcEventLogger - [bind: 1->name:'My Site #1', 2->vhost:'mysite1.example.org']
INFO CommonsJdbcEventLogger - Generated PK: domain.id = 1
INFO CommonsJdbcEventLogger - === updated 1 row.
----

=== Read Collection of Entities with `GET`

You may create more Domain objects, executing `POST` request above. Now
let's write a `GET` method to search for domains:

[source, Java]
----
import io.agrest.DataResponse;
import io.agrest.Ag;

...

@GET
public DataResponse<Domain> getAll(@Context UriInfo uriInfo) {
    return Ag.select(Domain.class, config).uri(uriInfo).get();
}
----

The above is a typical "select chain". Now `GET` can be invoked from the
client like this:


`curl -i -X GET 'http://example.org/myapp/domain'`

[source, JSON]
----
HTTP/1.1 200 OK
Content-Type: application/json

{
    "data" : [
        { "id" : 1, "name" : "My Site #1", "vhost" : "mysite1.example.org" },
        { "id" : 2, "name" : "My Site #2", "vhost" : "mysite2.example.org" }
    ],
    "total" : 2
}
----

Since select chain above incorporates UriInfo, it will recognize Agrest control
parameters passed from the client (see link:/protocol#control-parameters[Control Parameters]). Let's try using "cayenneExp" filter and "include":


`curl -i -X GET 'http://example.org/myapp/domain?exp=vhost="mysite1.example.org"&amp;include=id'`

[source, JSON]
----
HTTP/1.1 200 OK
Content-Type: application/json

{
    "data" : [
        { "id" : 1 }
    ],
    "total" : 1
}
----

=== Read a Single Entity with `GET`

A common request is to locate a single instance of an entity by ID. Here is how
this can be done with Agrest:

[source, Java]
----
import io.agrest.DataResponse;
import io.agrest.Ag;

...

@GET
@Path("{id}")
public DataResponse<Domain> getOne(@PathParam("id") int id, @Context UriInfo uriInfo) {
    return Ag.select(Domain.class, config).byId(id).uri(uriInfo).getOne();
}
----

Here we are binding "id" as a URL path parameter, but also notice that Agrest doesn't
mandate any specific place in the URL for ID. This is a decision made by the developer.
Calling this endpoint, we'll get an expected result:

`curl -i -X GET 'http://example.org/myapp/domain/1'`

[source, JSON]
----
HTTP/1.1 200 OK
Content-Type: application/json

{
    "data" : [
        { "id" : 1, "name" : "My Site #1", "vhost" : "mysite1.example.org" }
    ],
    "total" : 1
}
----

Even though we expect at most one object to be returned, the response is the same Collection
Document as we've seen before.

=== Update Entity with `PUT`

To update the entity we created before <<Create Entity with `POST`>> we have to implement a `PUT` method in DomainResource class:

[source, Java]
----
import io.agrest.Ag;
import io.agrest.SimpleResponse;

...

@PUT
@Path("{id}")
public SimpleResponse update(@PathParam("id") int id, String data) {
    return Ag.update(Domain.class, config).id(id).sync(data);
}
----

This simple "update chain" is very similar to the <<Create Entity with `POST`>> and the <<Read a Single Entity with `GET`>> chains.
Try to sent a request to this endpoint and get a result as expected

```
curl -i -X PUT 'http://example.org/myapp/domain/1' \
>          -d '{"vhost":"mysite2.example.org","name":"My Site #2"}'
```

[source, JSON]
----
HTTP/1.1 200 OK
Content-Type: application/json

{"success":true}
----

Apart of that, Agrest provides other ways to update entity with `PUT`. Please, refer to <<Idempotency of Updating Chains>> for more information.