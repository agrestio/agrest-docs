== REST Endpoints

=== Create data with POST

Let's write a couple of POST endpoints to allow users to create Authors and Books. We'll start by creating Java classes
`AuthorApi` and `BookApi`, placing a few JAX-RS annotations on them, and injecting JAX-RS `Configuration` object:

[source,java,indent=0]
----
include::../../../main/java/io/agrest/tutorial/sb/api/AuthorApi.java[tag=base]
----

[source,java,indent=0]
----
include::../../../main/java/io/agrest/tutorial/sb/api/BookApi.java[tag=base]
----

Now let's create POST methods in both classes. In `AuthorApi`:
[source,java,indent=0]
----
include::../../../main/java/io/agrest/tutorial/sb/api/AuthorApi.java[tag=post]
----
<1> Start a builder for "create" operation. `config` parameter passed to `create(..)`, contains Agrest runtime
<2> Pass URL parameters. This will control the shape of the response
<3> Execute create operation and return created Author to the client

In `BookApi`
[source,java,indent=0]
----
include::../../../main/java/io/agrest/tutorial/sb/api/BookApi.java[tag=post]
----
Notice the difference between Author and Book POST methods. In the former case, after creating an object
Agrest returns `DataResponse<Author>`, allowing the client to inspect the result of the operation (e.g. obtain the
Author's ID generated by the server). In the latter case, it returns `SimpleResponse` that does not contain any data.

=== REST App Class

Now that we have a few endpoint, how do we integrate them in our app? Let's create a main class of our SpringBoot
application called `AgrestApp` with some bootstrap code:

[source,java,indent=0]
----
include::../../../main/java/io/agrest/tutorial/sb/AgrestApp.java[tag=all]
----
<1> Our app class extends `ResourceConfig` coming from Jersey (our JAX-RS provider). Jersey configuration normally
happens in the `ResourceConfig` constructor (as described below), and the `ResourceConfig` is then automatically loaded
by SpringBoot on startup.
<2> Create Cayenne runtime
<3> Create Agrest runtime with Cayenne backend
<4> Register Agrest runtime with Jersey / JAX-RS environment
<5> Register API endpoints with Jersey

=== Run the App and Create Data

Now we can run the main class in the IDE, and use `curl` or a similar HTTP client to create some data:

[source,bash]
----
curl -X POST -i \
  -d '{"name":"Ernest Hemingway","dateOfBirth":"1899-07-21"}' \
  -H 'Content-Type: application/json' \
  http://localhost:8080/author
----
The response might look like this (note the id value, we'll need it to create Books) :

[source]
----
HTTP/1.1 201
Content-Type: application/json
Content-Length: 55
Date: Sat, 14 May 2022 09:39:39 GMT
----
[source,json]
----
{"data":[{"id":1,"dateOfBirth":"1899-07-21","name":"Ernest Hemingway"}],"total":1}
----

Now let's create a `Book`. In the following POST request, use the ID of the author from the previous call:
[source,bash]
----
curl -X POST -i \
  -d '[{"title":"A Farewell to Arms","author":1},{"title":"For Whom the Bell Tolls","author":1}]' \
  -H 'Content-Type: application/json' \
  http://localhost:8080/book
----
Since `BookApi` used `SimpleResponse`, the JSON returned will be just an acknowledgement of success:
[source]
----
HTTP/1.1 201
Content-Type: application/json
Content-Length: 16
Date: Sat, 14 May 2022 09:43:01 GMT
----
[source,json]
----
{"success":true}
----

=== Select Data

Now that we have some data in the DB, let's build an endpoint to retrieve it via `GET` requests. In `BookApi` add
the following method:
[source,java,indent=0]
----
include::../../../main/java/io/agrest/tutorial/sb/api/BookApi.java[tag=get]
----
Now you can restart the app, and run the  following request:
[source,bash]
----
curl http://localhost:8080/book
----

[source,json]
----
{
  "data":[
    {"id":1,"title":"A Farewell to Arms"},
    {"id":2,"title":"For Whom the Bell Tolls"}
  ],
  "total":2
}
----
Since we passed all URL parameters directly to Agrest (via `clientParams(uriInfo.getQueryParameters())`), we can
pass various Agrest protocol keys in the URL, to filter the result, resolve related objects, etc. Some examples:

Include Author in the response, and exclude ids:
[source,bash]
----
curl 'http://localhost:8080/book?exclude=id&include=author.name'
----

[source,json]
----
{
  "data":[
    {"author":{"name":"Ernest Hemingway"},"title":"For Whom the Bell Tolls"},
    {"author":{"name":"Ernest Hemingway"},"title":"A Farewell to Arms"}
  ],
  "total":2
}
----

Sort by title:
[source,bash]
----
curl 'http://localhost:8080/book?include=title&sort=title'
----

[source,json]
----
{
  "data":[
    {"title":"A Farewell to Arms"},
    {"title":"For Whom the Bell Tolls"}
  ],
  "total":2}
----

=== Update Data

Similar to how we implemented `POST`, you can also write `PUT` endpoints. We are leaving it as an exercise for the
reader, but here are some hints:

* `PUT` requires an `id` attribute to be present for each object in the request payload.
* You would need to use `AgJaxrs.update(..)` method to process the request.

NOTE: PUT can be used not only for updates, but also for "create-or-update" operations. Agrest has
special methods for those: `AgJaxrs.createOrUpdate(..)`, `AgJaxrs.idempotentCreateOrUpdate(..)`, etc. Those work with objects
that have https://en.wikipedia.org/wiki/Natural_key[natural keys] understood by the client. This is not directly
applicable to our Book and Author entities, though with a bit of a stretch we can use `Author.name` property as
a natural key.

